<!DOCTYPE html> 
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Recursividad en Programación</title>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", Arial, sans-serif;
      background: #f0f2f5;
      color: #333;
    }
    header.hero {
      background: url("https://images.unsplash.com/photo-1555949963-aa79dcee981c") no-repeat center center/cover;
      height: 250px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      text-align: center;
    }
    header .overlay {
      background: rgba(0,0,0,0.6);
      padding: 20px;
      border-radius: 10px;
    }
    nav {
      background: #1e1e2f;
      padding: 10px;
    }
    nav ul {
      display: flex;
      justify-content: center;
      gap: 20px;
      list-style: none;
      margin: 0;
      padding: 0;
    }
    nav ul li a {
      color: #fff;
      text-decoration: none;
      font-weight: bold;
      transition: color 0.3s;
    }
    nav ul li a:hover {
      color: #00c3ff;
    }
    main {
      max-width: 1000px;
      margin: auto;
      padding: 20px;
    }
    .card {
      background: #fff;
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      transition: transform 0.3s;
    }
    .card:hover {
      transform: translateY(-5px);
    }
    h2 {
      color: #004aad;
    }
    .img {
      display: block;
      max-width: 150px;
      margin: 15px auto;
    }
    pre {
      background: #222;
      color: #0f0;
      padding: 10px;
      border-radius: 8px;
      overflow-x: auto;
    }
    footer {
      background: #1e1e2f;
      color: #fff;
      text-align: center;
      padding: 15px;
    }
  </style>
</head>
<body>

  <!-- Integrantes -->
  <section class="card" style="text-align:center; background:#e3f2fd;">
    <h2>Integrantes</h2>
    <p><b>• Leonardo Victoria Navarrete<br>
    • Magaly Torres Marcelo<br>
    • Carlos Dario Dominguez Sanchez</b></p>
  </section>

  <!-- Encabezado -->
  <header class="hero">
    <div class="overlay">
      <h1>Recursividad en Programación</h1>
      <p>Definición, características, ejemplos y aplicaciones</p>
    </div>
  </header>

  <!-- Barra de navegación -->
  <nav>
    <ul>
      <li><a href="#definicion">Definición</a></li>
      <li><a href="#procedimientos">Procedimientos</a></li>
      <li><a href="#caracteristicas">Características</a></li>
      <li><a href="#ejemplos">Ejemplos</a></li>
      <li><a href="#fractal">Fractales</a></li>
      <li><a href="#conclusion">Conclusión</a></li>
      <li><a href="#referencias">Referencias</a></li>
    </ul>
  </nav>

  <!-- Contenido principal -->
  <main>
    <!-- Definición -->
    <section id="definicion" class="card">
      <h2>Definición</h2>
      <p>
        La <b>recursividad</b> es un principio fundamental en la programación y en las matemáticas. Consiste en resolver un problema definiéndolo en términos de una versión más pequeña de sí mismo. Una función recursiva es aquella que dentro de su propio código hace referencia a sí misma. Esto puede sonar paradójico al inicio, pero es extremadamente útil cuando se trabaja con problemas que tienen una naturaleza repetitiva o que se pueden descomponer en subproblemas más simples. Un ejemplo clásico es el cálculo del factorial de un número, donde el factorial de n se define como n multiplicado por el factorial de (n-1), y así sucesivamente hasta llegar a la base de 0! = 1. La recursividad es empleada no solo en cálculos matemáticos, sino también en algoritmos de búsqueda, ordenamiento y estructuras jerárquicas como árboles y grafos. Es importante destacar que una función recursiva siempre debe tener una <b>condición de terminación</b>, conocida como caso base, para evitar un ciclo infinito que provoque errores en la ejecución. Gracias a la recursividad, muchos algoritmos se vuelven más claros y elegantes, aunque requieren un manejo cuidadoso de los recursos del sistema [1][2].
      </p>
      <img src="https://cdn-icons-png.flaticon.com/512/3209/3209265.png" alt="Definición recursividad" class="img">
    </section>

    <!-- Procedimientos -->
    <section id="procedimientos" class="card">
      <h2>Procedimientos y Aplicaciones</h2>
      <p>
        Los procedimientos recursivos se emplean ampliamente en ciencias de la computación debido a su capacidad de simplificar problemas complejos. Un procedimiento recursivo puede dividir una tarea en múltiples pasos más pequeños hasta llegar a un caso base que pueda resolverse directamente. Una de sus aplicaciones más comunes está en el cálculo del <b>factorial</b>, pero también en la generación de la <b>sucesión de Fibonacci</b>, la resolución de las <b>Torres de Hanói</b> o la construcción de <b>fractales</b> como el triángulo de Sierpinski. En algoritmos de ordenamiento como <b>QuickSort</b> y <b>MergeSort</b>, la recursividad permite dividir la lista en segmentos más pequeños que se ordenan de manera independiente y luego se combinan. Asimismo, en estructuras de datos como árboles y grafos, se utilizan procedimientos recursivos para recorrer nodos, buscar información y organizar datos jerárquicos. Por ejemplo, una búsqueda en un árbol binario de búsqueda se implementa naturalmente con recursividad, ya que en cada paso se compara el valor buscado y se decide explorar el subárbol izquierdo o derecho. En conclusión, los procedimientos recursivos son versátiles y aparecen en casi todas las áreas de la programación, desde la inteligencia artificial hasta la compresión de datos [3][4].
      </p>
      <img src="https://cdn-icons-png.flaticon.com/512/7150/7150859.png" alt="Algoritmos recursivos" class="img">
    </section>

    <!-- Características -->
    <section id="caracteristicas" class="card">
      <h2>Características</h2>
      <p>
        La recursividad posee varias características que la hacen única frente a los métodos iterativos tradicionales. En primer lugar, divide problemas complejos en piezas más simples, permitiendo que se resuelvan paso a paso hasta alcanzar un caso base. Otra característica esencial es la existencia de dicho <b>caso base</b>, que evita que la función recursiva caiga en un ciclo infinito. Además, la recursividad se asocia con un uso intensivo de la <b>pila de llamadas</b>, ya que cada llamada recursiva queda almacenada en la memoria hasta que se resuelve. Esto implica que, aunque los algoritmos recursivos pueden ser más fáciles de entender y programar, no siempre son los más eficientes en cuanto a memoria y tiempo de ejecución. Otro aspecto importante es la <b>claridad conceptual</b>: muchos algoritmos complejos, como búsquedas en profundidad en grafos, se entienden de manera más intuitiva cuando se expresan de forma recursiva. Sin embargo, existe un equilibrio: en problemas que pueden resolverse con bucles simples, la recursividad puede generar sobrecarga innecesaria. En conclusión, la recursividad es poderosa, elegante y natural para muchos problemas, pero requiere del conocimiento de sus ventajas y limitaciones [5][6].
      </p>
    </section>

    <!-- Ejemplos -->
    <section id="ejemplos" class="card">
      <h2>Ejemplos de Recursividad</h2>
      
      <article>
        <h3>Factorial</h3>
        <pre><code>
function factorial(n) {
  if (n === 0) return 1;
  return n * factorial(n - 1);
}
        </code></pre>
        <p>
          El cálculo del factorial es el ejemplo más clásico de recursividad. El factorial de un número n (n!) se define como n multiplicado por el factorial de (n-1), hasta llegar al caso base de 0! = 1. Por ejemplo, factorial(5) se calcula como 5 × 4 × 3 × 2 × 1 = 120. La recursión permite expresar esta definición de manera directa en código, evitando bucles y mostrando de forma clara la relación entre un número y su antecesor. Es un ejemplo sencillo pero muy útil para introducir el concepto de recursividad [1][2].
        </p>
      </article>

      <article>
        <h3>Fibonacci</h3>
        <pre><code>
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
        </code></pre>
        <p>
          La sucesión de Fibonacci es otra aplicación clásica de recursividad. En esta secuencia, cada número es la suma de los dos anteriores, comenzando con 0 y 1. Usando recursividad, la función simplemente llama a sí misma para calcular fibonacci(n-1) y fibonacci(n-2), y suma sus resultados. Por ejemplo, fibonacci(6) devuelve 8. Aunque es elegante, este enfoque recursivo básico no es eficiente porque recalcula muchas veces los mismos valores; por ello, en la práctica se complementa con técnicas como <b>memoización</b>. Sin embargo, para fines educativos, este ejemplo ilustra de manera clara la potencia y simplicidad de la recursión [3][4].
        </p>
      </article>

      <article>
        <h3>Torres de Hanói</h3>
        <pre><code>
function hanoi(n, origen, destino, auxiliar) {
  if (n === 1) {
    console.log(`Mover disco 1 de ${origen} a ${destino}`);
    return;
  }
  hanoi(n - 1, origen, auxiliar, destino);
  console.log(`Mover disco ${n} de ${origen} a ${destino}`);
  hanoi(n - 1, auxiliar, destino, origen);
}
        </code></pre>
        <p>
          El problema de las Torres de Hanói es uno de los ejemplos más famosos de la recursividad. Consiste en mover una torre de discos desde un poste inicial hasta un poste final, utilizando un poste auxiliar y respetando la regla de no colocar un disco más grande encima de uno más pequeño. El procedimiento recursivo consiste en mover (n-1) discos al auxiliar, luego mover el disco más grande al destino y finalmente mover los (n-1) discos restantes al destino. Este problema ejemplifica perfectamente cómo la recursión divide un problema complejo en subproblemas más manejables [5].
        </p>
      </article>
    </section>

    <!-- Fractales -->
    <section id="fractal" class="card">
      <h2>Fractales y Recursividad</h2>
      <p>
        Los fractales son una representación visual de la recursividad en acción. Un fractal es una figura geométrica que se repite infinitamente a diferentes escalas, mostrando autosimilitud. El <b>triángulo de Sierpinski</b>, por ejemplo, se genera a partir de un triángulo equilátero al que se le eliminan subtriángulos en cada iteración. Este proceso se repite recursivamente, creando un patrón cada vez más complejo y detallado. Lo fascinante de los fractales es que muestran cómo una regla simple, aplicada recursivamente, puede dar lugar a figuras visualmente complejas y hermosas. Los fractales no solo son un ejemplo gráfico de recursividad, sino que también tienen aplicaciones en compresión de imágenes, gráficos por computadora, simulación de paisajes naturales y modelado de fenómenos físicos. En programación, implementarlos implica definir una función que dibuje una figura básica y que luego se llame a sí misma para dibujar versiones más pequeñas de esa figura en nuevas posiciones. Así, los fractales muestran de forma clara cómo la recursividad trasciende el ámbito matemático y se convierte en una herramienta para la representación visual y artística de la naturaleza [3][6].
      </p>
      <canvas id="fractalCanvas" width="400" height="400"></canvas>
    </section>

    <!-- Conclusión -->
    <section id="conclusion" class="card">
      <h2>Conclusión</h2>
      <p>
        La recursividad es mucho más que una técnica de programación: es un enfoque conceptual que permite resolver problemas mediante la división en subproblemas más pequeños. Su uso es fundamental en algoritmos matemáticos, en el manejo de estructuras de datos jerárquicas como árboles y grafos, en la representación visual de fractales y en problemas clásicos como Fibonacci y Torres de Hanói. Aunque su simplicidad y elegancia la hacen atractiva, también requiere precaución debido a la carga computacional y el consumo de memoria que implica. Entender la recursividad prepara a los estudiantes y programadores para enfrentar problemas complejos con soluciones claras y estructuradas. En la ciencia de la computación, dominar la recursión significa abrir la puerta a algoritmos más sofisticados, a la optimización de procesos y a la comprensión profunda de cómo una computadora organiza y resuelve tareas de manera estructurada. Sin duda, su estudio y aplicación son un pilar en la formación académica y profesional de cualquier desarrollador [1][2][6].
      </p>
    </section>

    <!-- Referencias -->
    <section id="referencias" class="card">
      <h2>Referencias</h2>
      <ol>
        <li>[1] AcademiaLab, “Recursividad (computación)”, Academia-Lab, 2025. [En línea]. Disponible en: 
          <a href="https://academia-lab.com/enciclopedia/recursividad-computacion/" target="_blank">academia-lab.com</a></li>
        <li>[2] Conceptos.es, “Recursividad”, 2025. [En línea]. Disponible en: 
          <a href="https://conceptos.es/recursividad" target="_blank">conceptos.es</a></li>
        <li>[3] AlgorEducation, “Recursividad en programación”, 2025. [En línea]. Disponible en: 
          <a href="https://cards.algoreducation.com/es/content/qiWpUzM1/recursividad-programacion" target="_blank">algoreducation.com</a></li>
        <li>[4] Codigonautas, “Recursión en programación”, 2025. [En línea]. Disponible en: 
          <a href="https://codigonautas.com/recursion-recursividad-programacion/" target="_blank">codigonautas.com</a></li>
        <li>[5] SignificadosWeb, “Recursividad: qué es y ejemplos”, 2025. [En línea]. Disponible en: 
          <a href="https://significadosweb.com/concepto-de-recursividad-que-es-definicion-significado-y-ejemplos/" target="_blank">significadosweb.com</a></li>
        <li>[6] EcuRed, “Recursividad”, 2025. [En línea]. Disponible en: 
          <a href="https://www.ecured.cu/Recursividad" target="_blank">ecured.cu</a></li>
      </ol>
    </section>
  </main>

  <!-- Footer -->
  <footer>
    <p>© 2025 Proyecto académico - GitHub Pages</p>
  </footer>

  <!-- Script fractal -->
  <script>
    const canvas = document.getElementById("fractalCanvas");
    if (canvas) {
      const ctx = canvas.getContext("2d");
      function drawTriangle(x, y, size) {
        ctx.moveTo(x, y);
        ctx.lineTo(x + size / 2, y - size);
        ctx.lineTo(x + size, y);
        ctx.closePath();
        ctx.stroke();
      }
      function sierpinski(x, y, size, depth) {
        if (depth === 0) {
          drawTriangle(x, y, size);
        } else {
          let newSize = size / 2;
          sierpinski(x, y, newSize, depth - 1);
          sierpinski(x + newSize / 2, y - newSize, newSize, depth - 1);
          sierpinski(x + newSize, y, newSize, depth - 1);
        }
      }
      ctx.strokeStyle = "#004aad";
      ctx.beginPath();
      sierpinski(50, 350, 300, 5);
      ctx.stroke();
    }
  </script>
</body>
</html>
